<!DOCTYPE html>
<meta charset="UTF-8">

<body>
    <input type="button" id="id_btn" value="눌러보셩">
</body>
<script>
    /* 요건 조금 배웠다는 사람은 다 할 수 있는거
    var myPrint = function(p_msg){
        document.write(p_msg+"<br>");
    } // 추상화, 원문을 감춤
    */

    /*
    // 참조(Reference)를 이해하는 사람이 생각할 수 있는 방식
    var myPrint = document.write; // 함수 포인터로 참조하는 방식, 문법적으로 문제 없으나...
    // myPrint("<h1>난 누가 뭐래도 최고</h1>"); <= 여기서 에러가 발생한다
    // document.write는 document에 포함된 write 메서드가 this로 document를 참조하는 방식
    // 따라서 myPrint의 this인자(document.write를 참조하며 생김)에
    // document 객체를 별도 지정해주고 변수를 넣어주면 정상적으로 작동한다
    myPrint.call(document, "<h1>난 누가 뭐래도 최고</h1>");
    */

    // 하지만 너무 길어짐... bind를 쓴다면?
    var myPrint = document.write.bind(document);
    // bind로 write의 this 참조를 document로 임의 고정함
    myPrint("<h1>난 누가 뭐래도 최고</h1>");
    // 자바스크립트 언어에 대한 이해도를 필요로 하는 방식

    // bind 첨엔 헷깔림
    var v_btn = document.querySelector("#id_btn");
    var f_click = function (p_arg) {
        console.log(this);
        alert("눌렀니?" + p_arg);
    }

    v_btn.addEventListener("click", f_click.bind(document, "만세~"))
    // 괄호를 붙이면 함수 포인터가 아니라 실행 구문이 됨
    // 매개변수가 필요한 함수는 함수 포인터로 불러올 수 없다...
    // 이럴 때 쓰는 것이 bind => bind(this, param) 로 사용하면 된다
    // bind는 뒤에서 몰래 함수를 만들어서 함수 포인터를 리턴해줌

    // v_btn.addEventListener("click", f_click.call(document, "만세~"))
    // call은 this를 제어하되 함수를 실행시켜 bind처럼 의도대로 작동하지 않음
    // 이벤트 리스너처럼 특정 이벤트에서만 함수 포인터로 사용해야 할 때에는 bind를 사용하고
    // this를 제어하고 실행되어도 무방한 경우에는 다른 제어 메서드 사용



</script>